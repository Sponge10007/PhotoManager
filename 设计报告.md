图片管理系统 (PhotoMS) 软件设计说明书1. 引言1.1 编写目的本设计说明书旨在为“图片管理网站”项目提供详细的架构设计、功能模块划分及数据库设计方案，作为后续开发（Coding）、测试及部署的指导依据。1.2 项目背景本项目为《BS体系软件设计》课程大作业。目标是构建一个基于 B/S 架构的图片管理平台，支持多端（PC/Mobile）访问，具备图片上传、管理、EXIF 自动解析、AI 智能分析及 LLM 对话检索（MCP）等功能。2. 系统总体设计2.1 技术架构选型本项目采用前后端分离架构。前端使用 TypeScript 保证交互逻辑的健壮性，后端使用 Go (Golang) 利用其静态强类型和高性能并发特性。前端 (Client):核心框架: React 18 + TypeScript构建工具: ViteUI 框架: Tailwind CSS (移动端优先策略) + Shadcn/UI (基于 Radix 的组件库)状态管理: Zustand (轻量级全局状态管理)网络请求: Axios + TanStack Query (管理服务端状态与缓存)后端 (Server):语言: Go (Golang) 1.21+Web 框架: Gin (轻量级、高性能，生态丰富，适合课程作业快速开发)ORM 框架: GORM (Go 语言中事实标准的 ORM，支持 MySQL，开发效率高)图像处理:disintegration/imaging: 纯 Go 实现的图像处理库（缩放、裁剪），避免了 CGO 带来的 Docker 部署复杂性。rwcarlsen/goexif: 用于提取 EXIF 元数据。数据库 (Database):主库: MySQL 8.0 (存储元数据)基础设施:容器化: Docker (多阶段构建) + Docker Compose3. 功能模块设计 (详细版)3.1 用户认证与安全模块 (Auth & Security)注册流程:输入验证: 后端使用正则表达式严格校验 Email 格式及密码复杂度（至少包含字母和数字，长度>6）。唯一性检查: 利用数据库 UNIQUE 索引处理并发注册时的冲突。密码存储: 使用 bcrypt 算法进行加盐哈希（Cost=10），严禁明文存储。鉴权机制:采用 JWT (JSON Web Token) 标准。Payload 设计: 包含 UserID、Role (用于未来扩展) 和 Exp (过期时间，设为 24 小时)。中间件: 实现 Gin Middleware，拦截非公开接口，验证 Header 中的 Authorization: Bearer <token>，校验失败直接返回 HTTP 401。安全策略:CORS: 配置允许的前端域名白名单。Rate Limiting: 针对登录接口增加 IP 维度的限流，防止暴力破解。3.2 图片全生命周期管理模块 (Image Lifecycle)上传子系统:文件校验: 不仅校验文件扩展名，还需读取文件头的前几个字节（Magic Number）校验 MIME 类型，防止伪装成图片的可执行文件上传。存储策略:物理路径采用 /uploads/{yyyy}/{mm}/{dd}/{uuid}.ext 结构，避免单文件夹下文件过多导致文件系统性能下降。文件名使用 UUID v4 重命名，防止中文乱码及文件名冲突。秒传机制: 上传前计算文件 SHA-256 哈希，查询数据库是否存在相同 Hash。若存在，直接复用文件路径，仅新增数据库引用记录。EXIF 解析与同步:关键字段: 解析 DateTimeOriginal (拍摄时间), Make/Model (设备), GPS (经纬度), FNumber (光圈), ExposureTime (快门)。数据清洗: 将 GPS 的度分秒格式转换为十进制经纬度，若无拍摄时间则回退使用文件创建时间。图片处理:缩略图生成: 上传成功后，异步生成宽 300px 的 WebP 格式缩略图（体积比 JPG 小 30% 以上），用于列表页快速加载。编辑功能: 前端提供裁剪框（react-image-crop）和滤镜参数（CSS filter），用户确认后，将参数传回后端或在前端 Canvas 处理完后作为新图片上传（非破坏性编辑）。3.3 检索与展示模块 (Search & Visualization)查询引擎:多维过滤: 支持 AND 组合查询，如 TakenTime > '2023-01-01' AND Tag IN ('Landscape')。分页策略: 采用基于游标（Cursor-based）或标准 Offset 分页。考虑到作业规模，使用标准 Offset 分页即可。前端交互优化:虚拟滚动 (Virtual Scrolling): 当图片数量超过 1000 张时，仅渲染视口内的 DOM 节点，保证页面流畅度。懒加载 (Lazy Load): 图片进入视口前显示占位色块或低清模糊图。移动端适配:响应式布局:Desktop: 4-5 列瀑布流。Tablet: 3 列。Mobile: 1-2 列（根据屏幕宽度动态计算）。手势操作: 支持左右滑动切换大图查看。3.4 智能增强模块 (AI & MCP)AI 异步分析:Worker Pool 模式: 后端维护一个带缓冲的 Channel (chan PhotoTask) 和一组 Worker Goroutine。处理流程: 图片上传完成 -> 发送任务 ID 到 Channel -> Worker 获取任务 -> 调用 Vision API -> 写入 Tags 表。避免外部 API 延迟阻塞上传接口。MCP (Model Context Protocol) 服务端:接口定义: 实现符合 MCP 规范的工具描述端点。Schema: 暴露 search_photos 工具，接受 query (SQL where 子句的自然语言描述) 或结构化参数 {"keyword": "cat", "start_date": "..."}。4. 数据库设计使用 GORM Struct 模型定义，自动迁移生成表结构。4.1 ERD 关系User (1) <--> (N) Photo <--> (N) Tag, (1) <--> (1) Exif4.2 数据表定义 (Go Struct 映射)User (用户表)type User struct {
    gorm.Model
    Username string `gorm:"uniqueIndex;type:varchar(100);not null"`
    Password string `gorm:"type:varchar(255);not null"` // Bcrypt hash
    Email    string `gorm:"uniqueIndex;type:varchar(100);not null"`
    Photos   []Photo
}
Photo (图片表)type Photo struct {
    ID          uint           `gorm:"primaryKey"`
    CreatedAt   time.Time
    UpdatedAt   time.Time
    DeletedAt   gorm.DeletedAt `gorm:"index"`
    UserID      uint           `gorm:"index;not null"`
    Title       string         `gorm:"type:varchar(255)"`
    Description string         `gorm:"type:text"`
    FileName    string         `gorm:"type:varchar(255);not null"`
    Path        string         `gorm:"type:varchar(512);not null"` // 原图存储路径
    ThumbPath   string         `gorm:"type:varchar(512);not null"` // 缩略图路径
    Hash        string         `gorm:"index;type:char(64);not null"` // SHA-256
    Size        int64          // 文件大小
    MimeType    string         `gorm:"type:varchar(50)"`
    ExifData    ExifData       // Has One 关系
    Tags        []Tag          `gorm:"many2many:photo_tags;"`
}
ExifData (EXIF信息表)type ExifData struct {
    PhotoID      uint      `gorm:"primaryKey"`
    CameraMake   string    `gorm:"type:varchar(100)"`
    CameraModel  string    `gorm:"type:varchar(100)"`
    LensModel    string    `gorm:"type:varchar(100)"`
    ISO          int
    Aperture     float64   // F值
    ShutterSpeed string    // 快门速度字符串，如 "1/100"
    FocalLength  float64
    Latitude     float64   // 纬度
    Longitude    float64   // 经度
    TakenAt      time.Time `gorm:"index"` // 拍摄时间，这是查询热点，必须加索引
}
Tag (标签表)type Tag struct {
    ID   uint   `gorm:"primaryKey"`
    Name string `gorm:"uniqueIndex;type:varchar(50);not null"`
    Type string `gorm:"type:enum('USER','AI');default:'USER'"` // 区分来源
}
5. 接口设计 (API Design)遵循 RESTful 风格。方法路径说明请求体/参数响应POST/api/v1/auth/register注册{username, email, password}{id, token}POST/api/v1/auth/login登录{email, password}{token, user}POST/api/v1/photos上传图片Multipart: file{id, url}GET/api/v1/photos图片列表?page=1&limit=20&tag=风景&start_date=...{data:[], meta:{total}}GET/api/v1/photos/:id详情-{photo_obj}PUT/api/v1/photos/:id编辑元数据{title, description, tags:[]}{status}DELETE/api/v1/photos/:id软删除-{status}POST/api/v1/mcp/queryMCP检索{prompt: "string"}{results: []}6. 详细设计与实现要点6.1 后端工程化设计 (Go)6.1.1 目录结构 (Clean Architecture 简化版).
├── cmd/
│   └── server/          # main.go 入口
├── internal/
│   ├── config/          # 配置文件加载 (Viper)
│   ├── controllers/     # HTTP Handler (Gin)
│   ├── models/          # GORM Struct 定义
│   ├── services/        # 核心业务逻辑 (上传处理、EXIF解析、AI调用)
│   ├── repository/      # 数据库访问层 (封装 GORM 操作)
│   └── middleware/      # JWT认证, CORS, RateLimit
├── pkg/
│   ├── utils/           # 通用工具函数 (Hash计算, UUID生成)
│   └── mcp/             # MCP 协议相关定义
└── uploads/             # 静态资源目录 (Docker Volume 挂载点)
6.1.2 错误处理规范统一封装 API 响应结构，所有 Handler 必须返回此结构：type Response struct {
    Code int         `json:"code"`    // 业务码: 0成功, >0 错误
    Msg  string      `json:"msg"`     // 提示信息
    Data interface{} `json:"data"`    // 数据载荷
}

// 中间件捕获 panic，防止服务崩溃
func RecoveryMiddleware() gin.HandlerFunc {
    return func(c *gin.Context) {
        defer func() {
            if err := recover(); err != nil {
                // Log error stack
                c.JSON(500, Response{Code: 500, Msg: "Internal Server Error"})
            }
        }()
        c.Next()
    }
}
6.1.3 并发与异步 (Goroutines)针对 AI 打标等耗时操作，不应阻塞 HTTP 响应。// services/ai_service.go
func ProcessImageAsync(photoID uint, filePath string) {
    go func() {
        // 创建一个上下文，设置超时防止 Goroutine 泄露
        ctx, cancel := context.WithTimeout(context.Background(), 30*time.Second)
        defer cancel()
        
        tags, err := CallVisionAPI(ctx, filePath)
        if err != nil {
            log.Printf("AI analysis failed for photo %d: %v", photoID, err)
            return
        }
        // 更新数据库 (需使用新 Session)
        repo.UpdatePhotoTags(photoID, tags)
    }()
}
6.2 前端实现细节 (TypeScript/React)6.2.1 API 客户端封装使用 axios 拦截器统一处理 Token 注入和 401 跳转。// src/lib/api.ts
api.interceptors.request.use((config) => {
  const token = useAuthStore.getState().token;
  if (token) {
    config.headers.Authorization = `Bearer ${token}`;
  }
  return config;
});
6.2.2 自定义 Hook: usePhotoUpload封装上传逻辑，提供进度反馈。export function usePhotoUpload() {
  const [progress, setProgress] = useState(0);
  
  const upload = async (file: File) => {
    const formData = new FormData();
    formData.append('file', file);
    
    return api.post('/photos', formData, {
      onUploadProgress: (progressEvent) => {
        const percent = Math.round((progressEvent.loaded * 100) / progressEvent.total!);
        setProgress(percent);
      }
    });
  };
  return { upload, progress };
}
6.3 MCP 接口实现逻辑MCP (Model Context Protocol) 核心在于将系统能力暴露给 LLM。定义工具: 告知 LLM 系统支持什么查询。Prompt Template:You are a photo search assistant. 
Translate the user's natural language query into a SQL-like JSON object.
Supported fields: "keyword" (matches title/desc/tags), "year", "month", "camera_model".

User: "Show me photos of food from last December"
Output: {"keyword": "food", "year": 2024, "month": 12}
后端解析与执行:后端接收 JSON，使用 GORM 的链式调用构建查询：func BuildQuery(params SearchParams) *gorm.DB {
    db := database.DB.Model(&Photo{})
    if params.Keyword != "" {
        db = db.Joins("JOIN photo_tags pt ON pt.photo_id = photos.id").
                Where("photos.title LIKE ? OR pt.tag_name LIKE ?", "%"+k+"%", "%"+k+"%")
    }
    // ... handle dates
    return db
}
